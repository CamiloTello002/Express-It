ReactDOM is the glue between React and the DOM (Document Object Model)
react-dom package is more for web integration
It literally renders the HTML elements


WHY DO WE USE className instead of class?
Because jsx is transpiled into JavaScript functions, and if you transpile it with 'class', you'll likely run into errors :(

What is the fr unit in CSS?
It stands for fraction (fraction of the available space). That helps us to specify sizes or lenghts relative to the AVAILABLE space in the GRID CONTAINER.
The pixels it actually occupies depend on two things: the 

What is rem? 
It stands for 'roo-em' units, and it dictates an element's font size to the size of the root element.
Keep in mind that is a RELATIVE sizing unit
It just REPRESENTS the font size of the ROOT element.
What does that mean?
1rem is the same as the font size of the HTML element.
This is usually 16px, which is the default value.
Why would we use it?
Because it ensures CONSISTENCY (in terms of font size and spacing).

Difference between rem and em?
em is RELATIVE to the own element.
rem is RELATIVE to the ROOT element

the advantage of rem is that we don't have to pay attention to nestings affecting the font size, whereas with rem we just take the root element as a reference

The pitfall of rem is that the font size might get somewhat difficult to use. Take a look at this reference:

10px = 0.625rem
12px = 0.75rem
14px = 0.875rem
16px = 1rem (base)
18px = 1.125rem
20px = 1.25rem
24px = 1.5rem
30px = 1.875rem
32px = 2rem

Look at this example:
p {
    font-size: 16px; /* 1em = 16px */
}

This one is more insightful

html {
    font-size: 100%; /* 100% = 16px */
}
p {
    font-size: 1em; /* 1em = 16px */
}
h1 {
    font-size: 2em; / 2em = 32px */
}

H
<time> element in HTML
I didn't know about this one. We can provide it with an attribute that has a machine-readable date

A little recap...
WHAT IS ROUTING?
It is the process of determining HOW an application RESPONDS to a given URL (or path). 
It usually maps URLs to specific pieces of application logic or COMPONENTS that should be rendered based on the url.

In React, we can define different "routes" inside our single-page application and RENDER different components based on the current URL.

So, when a route MATCHES the current URL, the corresponding component is rendered.

**History management**
If we route, it means we must manage the history stack. It's useful for allowing users to navigate forward and backward within the application WITHOUT reloading the entire page

**React Router DOM**
It uses the <BrowserRouter> component that utilizes the HTML5 history API, this helps to keep the UI in sync with the URL. 

Inside this BrowserRouter, we can define multiple Route elements, where we specify the path and the element to be rendered.
In this case, we can use render or component.
render is used for making a conditional logic for rendering a component, while component directly specifies the element to be rendered.
Another option is to drop the render or component attribute and specify the component to be rendered as a child component of Route.

We also have the option of making a component visible in ALL PAGES. We just put the component above the Route components.



## MISTAKE ##
I was trying to install a React dependency OUTSIDE of the client directory.
Please, don't do that again xd

Another note about BrowserRouter...
It STORES the current location in the browser's address bar using clean URLs. It also navigates using the browser's built-in HISTORY STACK


**MORE ABOUT ROUTING**
According to the docs, routing is about building a full user interface that MAPS to the URL.
*It has three fundamental jobs*
1. Subscribing and manipulating the HISTORY STACK
2. Match the URL to my ROUTES
3. Rendering a nested UI from the route matches.

Some distinctions:
- URL -> what you see in the address bar.
- Location -> React Router object and specifies WHERE the user is at.
- Location state -> Value with a location that persists in browser's memory
- History stack -> the history, basically.
- Client-side Routing -> enables devs to MANIPULATE the browser history stack WITHOUT making a document request to the server.
- History -> Object that allows React Router to subscribe to changes in the URL, and provides APIs to MANIPULATE the browser history stack programatically




So, what we've doing so far is to add the routes inside the App component

**Why Link component instead of a href element?**
Short answer: to avoid refreshing pages
Long answer: The intention of single page applications is to CALL a component ON THE SAME PAGE W I T H O U T refreshing the entire page.
Think about navbars. When you click a button, if the page refreshes itself, it means that it was called with the a href tag.
But sometimes we don't want the page to refresh at all. We just want it to render a component on the same page.

If we use Link instead of a href, we will get rid of this issue.


VAMOS POR EL MINUTO... 32:34


Often times, a component needs to return multiple elements at once. In order to achieve this in jsx, we need to use the fragment <> </>

Remember that when an element is displayed as a block, it occupies an entire line, not sharing it with another existing element



I just learned something:
Two blocks can be set to 100% but one of them can appear wider than the other.
Why could've that happened? Because of the padding. The width doesn't take into account the padding, causing an element to appear wider than the other, even if they are set to 100% of the width.
*Is there a way to fix this?*
Yes, just set the box-sizing to border-box.
What does that do? The WIDTH will take into account not only the content but also the padding. We'll apply it for every element